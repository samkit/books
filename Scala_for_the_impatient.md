#[Scala for the Impatient][]
> Author: Cay Horstmann

> Type: Ebook

##Chapter 1 - The Basics
######1.6. `apply == ()` call.

##Chapter 2 - Control Structures and Functions
######2.1. Use `:paste` on REPL to paste multiline code which interpreted can analyze and run.
######2.6. The generated collection is always compatible with first generator.
```scala
for (c <- "Hello"; i <- 0 to 1) yield (c + i).toChar
    // yields "HIeflmlmop"
for (i <- 0 to 1; c <- "Hello") yield (c + i).toChar
    // yields Vector('H', 'e', 'l', 'l', 'o', 'I', 'f', 'm', 'm', 'p')
```
######2.9. Use `_*` to tell the compiler that the preceding part is an argument sequence.
```scala
sum(1, 2, 3, 4)
```
is equivalent to
```scala
sum(1 to 4: _*)
```
Without this, '1 to 4' goes as a Range object.

######2.11. Lazy values,
```scala
lazy val words = scala.io.Source.fromFile("filename").mkString
```
> **Note**: Lazy variables are thread-safe and hence has a cost attached to it.

######2.12.
1. A throw expression has type "Nothing".
2. Type of if/else block when one of its branch is "Nothing", is the type of other branch.

```scala
try {
    // do something bad that throws
}
catch {
    // pattern match
    case _: SomeException => // do something
    case ex: IOException => // do something else
}
finally {
    // always called
    // Remember that variables defined inside try block is not visible here
}
```

##Chapter 3 - Working with arrays
######3.2. Mutable arrays like std::vector in C++
```scala
scala.collection.mutable.ArrayBuffer
```
######3.5.
1. Sorting Array in place, scala.util.Sorting.quickSort(array).
2. Array to string, Array.mkString(sep).

> ArrayOps / StringOps - useful implicit classes.

######3.7. Multidimensional arrays.
```scala
Array.ofDim(3, 4) // 3 rows, 4 columns
```
######3.8. Java interoparability
```scala
import scala.collection.JavaConversions.bufferAsJavaList // to convert scala buffer to java list
```

##Chapter 4 - Maps and Tuples
######4.3. Adding/removing keys from immutables maps are not very expensive. As the maps are immutable so both new and old ones share the same underlying data.

```scala
val newMap = oldMap - "existing_key"
```

######4.5. For having keys sorted in insertion order, use `LinkedHashMap`.

##Chapter 5 - Classes
######5.2.
1. Getter and setter methods are implicitly generated by scala comiler. And looks like:

```scala
class Person {
    var age = 10
    
    def age = this.age                              // implicitly generated
    def age_=(value: Int) { /* do something */ }    // implicitly generated
}
```

2. To see compiled class, use `scala -private Person`.

```
$ scalac Person.scala
$ scala -private Person
Compiled from "Person.scala"
public class Person extends java.lang.Object implements scala.ScalaObject{
    private int age;
    public int age();
    public void age_$eq(int);
    public Person();
}
```

> **Note**: For `private[this]` variables, getters and setters are not generated.

######5.5. To generate `get*` or `set*` style getters and setters, use `@BeanProperty`.

```scala
class Person {
    @BeanProperty var age = 10
    
    def age                 // generated
    def age_=(value: Int)   // generated
    def getAge()            // generated
    def setAge(value: Int)  // generated
}
```

######5.6. Every auxiliary constructor must call previously defined auxiliary constructor or primary constructor.
######5.7.
1. If `val` or `var` is not specified in the primary constructor and variables are used by at least one method then the fields are object-private. If not accessed, then its not a member variable.
2. To make primary constructor private place `private` before it.

######5.8. Nested classes are distinct types even on two objects of same enclosing class.

```scala
class OuterClass {
    class InnerClass {
    }
}
val first = new OuterClass
val second = new OuterClass

// first.InnerClass and second.InnerClass are different types.
```

```scala
class Person private(var age: Int)
```

To resolve this use *type projection*, like:

```scala
class OuterClass {
    class InnerClass {
    }
    
    var objects: Array[OuterClass#InnerClass] = _       // means InnerClass of any OuterClass object
}
```

##Chapter 6 - Objects
######6.6. Enumeration with string names.

```scala
object Color extends Enumeration {
    val Yellow = Value(0, "Yellow")
    val Red = Value(1, "Red")
}
```

##Chapter 7 - Packages and Imports
######7.2. Using absolute package names.
```scala
type Map = _root_.scala.collection.mutable.Map
```

######7.3. Chained package clause
```scala
package com.horstman.impatient {
    // members of com, com.horstman are invisible here
    package Utils {
        object MathFunctions {
        }
    }
}
```

######7.4. [7.3] is equivalent to top of file notation.
```scala
package com.horstman.impatient
package Utils

object MathFunctions {
}
```

######7.5. Package object can be used to encapsulate free variables and free functions, which otherwise will go into a companion object. The package object is implemented as a object name `package` inside the given package.
```scala
package com.horstmann.impatient
package object people {     // an object named com.horstmann.impatient.people.package is created, visible to JVM
    val defaultName = "John Q. Public"
}
```

######7.9. Imports
1. Renaming imports.

    ```scala
    import java.util.{HashMap => JavaHashMap}
    ```

2. Hiding imports.

    ```scala
    import java.util.{HashMap => _, _}  // imports everything except HashMap from java.util package
    ```

######7.10. Implicit imports.
```scala
import java.lang._
import scala._      // Special case: it overrides previous imports like java.lang.StringBuilder with scala.StringBuilder
import Predef._
```

##Chapter 8 - Inheritance
######8.6. A `val` or parameter-less `def` method can be overriden with a `val` in child class.
```scala
class Person {
    def id: Int     // abstract
}

class Student(override val id: Int) extends Person
```
Rules:

1. Only a `def` can override `def`.
2. A `val` can override a `val` or parameter-less `def`.
3. A `var` can only override an abstract `var`.

######8.7. Anonymous class
```scala
def meet(p: Person{def greeting: String}) {
    println(p.name + " says: " + p.greeting)
}
```

######8.10. Construction and early access of overridden `val`.
```scala
class Creature {
    val range: Int = 10
    val env: Array[Int] = new Array[Int](range)     // Here, range == 0. Read explanation in the book.
}

class Ant extends Creature {
    override val range = 2
}
```

> **Note**: If you want to use `val` in constructor body then make it final.
> **Note**: Use -Xcheckinit while compiling. This results in exception if uninitialized variables are accessed.

This can be solved by doing this _ugly_ thing.
```scala
class Ant extends {
    override val range = 2
} with Creature
```

######8.12. Override `equal` and `hashCode` methods together, where ever possible. And use `lhs: Any` in `equal` method, and not the type of the same object.

##Chapter 9 - Files and Regular Expressions
######9.8. Serialization.
```scala
@SerialVersionUID(42L) class Person extends Serializable
```
> **Note**: `@SerialVersionUID` if removed, generates default UID.

######9.9. Writing shell commands.
Command | What does it does?
--- |---
`"ls -l" !` | Return code of the shell command
`"ls -l" !!` | Output of shell command as a string
`"ls -l" #| "grep something" !` | Pipe the output to another command
`"ls -l" #> new File("output.txt") !` | Redirect output to a file
`"ls -l" #>> new File("output.txt") !` | Redirect(append) output to a file
`"grep sec" #< new File("output.txt") !` | Redirect input from a file
`"grep Scala" #< new URL("http://horstmann.com/index.html") !` | Redirect input from a URL

######9.11. Regular expression groups and pattern matching
```scala
val numitemPattern = "([0-9]+) ([a-z]+)".r
val numitemPattern(num, item) = "99 bottles"
// Sets num to "99", item to "bottles"
```

[Scala for the Impatient]: http://www.amazon.in/Scala-Impatient-Cay-S-Horstmann/dp/8131796051/ref=sr_1_1?ie=UTF8&qid=1376238658&sr=8-1&keywords=scala+for+the+impatient